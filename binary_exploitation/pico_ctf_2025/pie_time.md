### PIE TIME

**Description:**    
We are given access to a remote service through **netcat**. The service provides us with the memory address of the `main` function at runtime and asks us to input an address to jump to. The goal is to use this leaked address to calculate the correct memory location of a hidden function (`win`) and execute it in order to obtain the flag.

**Approach:**

1. **Connect to the remote service:**

   ```bash
   nc rescued-float.picoctf.net 53106
   ```

   Example output:
   ```
   Address of main: 0x5e5090adf33d
   Enter the address to jump to, ex => 0x12345:
   ```

2. **Analyze the binary:**

   We use the `nm` tool to extract the memory offsets of the key functions:

   ```bash
   nm vuln | grep ' main\| win'
   ```

   Example output:
   ```
   000000000000133d T main
   00000000000012a7 T win
   ```

   **Explanation:**

   * `nm vuln` lists all the **symbols** (functions and variables) present in the binary along with their offsets.
   * `grep ' main\| win'` filters the output to show only the lines containing `main` or `win`.

   Each line has three parts:

   * `000000000000133d` → This is the **offset** (position) of the function in the binary, in hexadecimal.
   * `T` → This letter indicates the type of symbol. `T` means the function is located in the **Text Section** (i.e., it is executable code). Other letters could appear in different contexts, like `B` for uninitialized data or `D` for initialized data.
   * `main` or `win` → The name of the function.

   The difference between the offsets is:

   ```
   0x133d (main) - 0x12a7 (win) = 0x96
   ```

   This means that the `win` function is located **0x96 bytes before** the `main` function.

3. **Calculate the address to jump to:**

   The binary is compiled with **PIE (Position Independent Executable)**, meaning its actual memory addresses change every time it runs. However, the program leaks the actual memory address of `main` at runtime.

   Using the known static difference between `main` and `win`, we can compute the real address of `win`:

   ```
   real_win = leaked_main - (offset_main - offset_win)
   real_win = leaked_main - 0x96
   ```

4. **Send the correct address:**

   Example calculation:

   * Leaked `main`: `0x5e5090adf33d`
   * Address to jump to: `0x5e5090adf33d - 0x96 = 0x5e5090adf2a7`

   Input this address into the program:

   ```
   0x5e5090adf2a7
   ```

   The program responds:

   ```
   You won!
   picoCTF{b4s1c_p051t10n_1nd3p3nd3nc3_378c1259}
   ```

5. **Flag found:**

   ```
   picoCTF{b4s1c_p051t10n_1nd3p3nd3nc3_378c1259}
   ```

**How the exploit works:**

1. The program leaks the **actual address of `main`** at runtime, defeating the randomness introduced by PIE for that function.
2. We know the **relative offset** between `main` and `win` by inspecting the binary using `nm`.
3. We subtract this fixed difference from the leaked address to compute the **real runtime address of `win`**.
4. By supplying this address, the program calls the hidden `win` function, revealing the flag.

**About PIE (Position Independent Executable):**

* PIE is a security feature that **randomizes where code is loaded in memory** to make exploitation more difficult.
* If an attacker can leak a valid address (like the address of `main`), they can compute other addresses using **relative offsets**.
* This type of vulnerability highlights the importance of avoiding both **address leaks** and **unchecked function pointers** in secure programming.

**Takeaways:**

* Even with PIE, **address leaks** can make exploitation possible.
* Always validate and restrict user inputs, especially when they control function pointers or addresses.
* Understanding **offsets** and **memory layout** is key in binary exploitation and reverse engineering.
